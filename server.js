const path = require("path");
const express = require("express");
const app = express();
const server = require("http").Server(app);
//const port = 3000;

const roomMax = 9;

const notes = [
  { id: "x", note: "D3" },
  { id: "x", note: "F3" },
  { id: "x", note: "G3" },
  { id: "x", note: "A3" },
  { id: "x", note: "C4" },
  { id: "x", note: "E4" },
  { id: "x", note: "G4" },
  { id: "x", note: "A4" },
  { id: "x", note: "C5" },
  { id: "x", note: "D5" }
];
var activeNotes = [];

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Our app is running on port ${ PORT }`);
});

// server.listen(port, () => {
//   console.log("server is listening on port " + port);
// });

app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "public/index.html"));
});

app.use(express.static("public"));
app.use(express.static("node_modules/p5/lib"));
app.use(express.static("node_modules/p5/lib/addons"));

// === socket stuff ===

const io = require("socket.io")(server);

io.on("connection", socket => {
  /// -- room assignment zone -- ///

  console.log("--- connection notes ---");
  console.log("total client count: " + io.engine.clientsCount);

  let theRoom = 0; // this is where we'll store the room that the new socket will be assigned to.
  var realRooms = Object.keys(io.sockets.adapter.rooms).reduce(
    (filtered, key) => {
      if (!io.sockets.adapter.rooms[key].sockets.hasOwnProperty(key))
        filtered.push(key);
      return filtered;
    },
    []
  ); // this is an array containing the names of all the rooms, filtering out the 'fake' rooms auto generated by socket.io
  let roomAmount = realRooms.length; // how many rooms are there?
  let roomExists = false;
  theRoom = roomAmount;
  console.log("room count: " + roomAmount + " - " + realRooms);
  if (roomAmount > 0) {
    for (var i = 0; i < roomAmount; i++) {
      // go through each of the existing rooms
      let roomMembers = io.sockets.adapter.rooms[realRooms[i]].length; // how many people are in the room?
      console.log("there are already " + roomMembers + " people in room" + i);
      if (roomMembers < roomMax) {
        // is the number below the max and is there room for one more?
        //console.log('theres room');
        // if yes...
        theRoom = i;
        roomExists = true;
        break; // get outta the loop. do we need this?
      }
      if (roomMembers >= roomMax && i == roomAmount - 1) {
        // have we gone thru all the rooms? do we need to make a new room?
        console.log("making new room");

        theRoom = i + 1;
      }
    }
  }
  var roomName = "room" + theRoom;
  if (roomExists == false) {
    activeNotes[theRoom] = [];
  }
  //console.log('socket ' + socket.id + ' assigned to ' + roomName+ ' which now has '+ io.sockets.adapter.rooms[roomName].length + ' members');

  socket.join(roomName);
  console.log(
    "socket " +
      socket.id +
      " assigned to " +
      roomName +
      " which now has " +
      io.sockets.adapter.rooms[roomName].length +
      " members"
  );
  //console.log(io.sockets.adapter.rooms[roomName].length); // this tells us how many people are in the room
  //-- room assignment stuff done --//
  console.log('---');
  // --- note assignment zone --- //
  let uniqueNotes = notes.filter(
    o1 => !activeNotes[theRoom].some(o2 => o1.note === o2.note)
  );
  //console.log(uniqueNotes);
  var theNote = uniqueNotes[Math.floor(Math.random() * uniqueNotes.length)];
  theNote.id = socket.id;
  //console.log(theNote);
  activeNotes[theRoom].push(theNote);
  //console.log(activeNotes[theRoom]);
  socket.emit("incomingNote", theNote.note);

  
  socket.on("eyeChange", data => {
    //socket.broadcast.emit("incomingEyes", data);
    socket.to(roomName).emit("incomingEyes", data);
  });
  socket.on("disconnect", reason => {
    console.log("--- disconnection notes ---");
    //note cleanup stuff
    //console.log(socket.id + " disconnected");
    //go through activeNotes array, find socket ID and remote (array.split) the note that matches the array so that it is free to be grabbed again
    var noteToDelete;
    for (var i = 0; i < activeNotes[theRoom].length; i++) {
      if (activeNotes[theRoom][i].id == socket.id) {
        noteToDelete = i;
      }
    }
    if (noteToDelete > -1) {
      activeNotes[theRoom].splice(noteToDelete, 1);
      console.log(
        "there are " +
          activeNotes[theRoom].length +
          " active notes in room " +
          theRoom +
          ": "
      ); // debug thing - note count before
      console.log(activeNotes[theRoom]);
    }
    var roomList = io.sockets.adapter.rooms[roomName];
    
    console.log("total client count: " + io.engine.clientsCount);

    if (roomList === undefined) {
      console.log("nobody is in the room anymore");
      // add a cleanup function when client count hits 0 that resets the activenotes arrays in case some bad data gets in?
    } else {
      console.log("people left in the room: " + roomList.length);
      console.log(
        "there are " + activeNotes[theRoom].length + " active notes in the room"
      );
    }
    
    socket.to(roomName).emit("removeEyes", socket.id);
  });
});
